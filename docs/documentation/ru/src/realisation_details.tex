\section{Подробности реализации JMantic}

\subsection{Иерархия sc-типов}

В JMantic представлен один абстрактный родительский тип ScElement и 3 типа конкретных sc-элементов: ScNode, ScEdge, ScLink. Также ScLink имеет 4 подтипа, для каждого варианта возможного содержимого: ScLinkInteger, ScLinkFloat, ScLinkString, ScLinkBinary.

Дерево типов выглядит следующим образом: 


\begin{tikzpicture}[sibling distance=4pt]
\tikzset{edge from parent/.style=
{draw,
edge from parent path={(\tikzparentnode.south)
-- +(0,-8pt)
-| (\tikzchildnode)}}}
\tikzset{level distance=30pt}
\Tree [.ScElement 
[.ScNode  ]
[.ScEdge  ]
[.ScLink ScLinkInteger ScLinkFloat ScLinkString ScLinkBinary ]
]
\end{tikzpicture}

\subsection{Интерфейс ScMemory}
Интерфейс ScMemory является ядром библиотеки. Именно данный интерфейс описывает контракт между java-кодом и sc-памятью. В интерфейсе определено множество методов.
\subsubsection{createNodes}
Данный метод, как понятно и названия, создаёт узлы (один или несколько) в sc-памяти. Методу передаётся список типов. Для каждого элемента списка будет создан узел с соответствующим типом. Метод вернёт список объектов типа ScNode. 

В контексте Ostis, данный метод создаёт и отправляет один запрос на создание группы элементов. 

\subsubsection{createEdges}
Как и метод createNodes, данный создаёт sc-элементы в остисе, а точнее -- дуги. Для создания дуг в этот метод необходимо передать узлы, между которыми создастся дуга, а также тип создаваемой дуги. Метода возвращает список объектов, которые реализуют ScEdge. 

Как и в случае с createNodes, в Ostis будет послан один запрос с набором всех дуг, которые необходимо создать. 

\subsubsection{createLinks}
Данного метода нет в интерфейсе, но вместо него объявлены методы для каждого типа ScLink. Все контракты применимы к любому из группы методов. 

Каждый метод создаёт в sc-памяти ScLink с содержимым определённого типа (integer, float, string). Для использования метода, ему необходимо передать список sc-типов самих sc-элементов (var, const и т.д.), а также список содержимого соответствующего типа (integer, float, string). Для каждого элемента списка типов будет создан ScLink с соответствующим содержимым из списка содержимого. В результате вернётся список объектов, которые наследуются от одного из конкретных вариантов ScLink (ScLinkInteger, ScLinkFloat, ScLinkString)

В каждом методе в Ostis будет отправлен один запрос. То есть, один запрос, но все ScLink в этом запросе будут иметь единый тип содержимого. 

\subsubsection{deleteElements}
Метод для удаления любого sc-элемента из sc-памяти. Ему нужно передать список sc-элементов, которые хочется удалить. Вернёт метод статус --- true, если удаление прошло успешно, false в ином случа. 

Как и все предыдущие методы, при работе с Ostis будет отправлен один запрос с списком адресов всех элементов, которые нужно удалить. 

\subsubsection{findByTemplateNodeEdgeNode}
Данный метод является одним из методов поиска по шаблону. Если точнее, то этот метод ищет конструкции вида узел-дуга-узел при известном одном из узлов. Для работы методу требуется передать ScNode, который будет играть роль фиксированного узла, а также тип дуги и тип второго узла. В результате работы, метод вернёт список ScEdge, где каждая дуга одним концом присоединена к фиксированому узлу. 

Если библиотека настроена на работу с Ostis, то в данном методе будет составлен один запрос, который будет послан серверу. 

\subsubsection{find}

Универсальный метод для поиска любых допустимых конструкций в sc-памяти. Данный метод принимает объект типа ScPattern, и возвращает список найденных конструкций по данному шаблону. 

\subsubsection{findByPattern3}

Данный метод является частным случаем поискового запроса find. Если точнее, данный метод предназначен для поиска по шаблону из 3-х элементов. Отличие от универсального метода поиска в наличии проверки типов на этапе компиляции а также облегченный способ создания объектов шаблонов ScPattern3 с помощью фабрик DefaultScPattern3Factory и ScPattern3FactoryWithNames. 

\subsubsection{findByPattern5}

Данный метод является частным случаем поискового запроса find. Если точнее, данный метод предназначен для поиска по шаблону из 5-и элементов. Отличие от универсального метода поиска в наличии проверки типов на этапе компиляции а также облегченный способ создания объектов шаблонов ScPattern5 с помощью фабрик DefaultScPattern5Factory и ScPattern5FactoryWithNames. 

\subsubsection{setLinkContent}
Данного метода не объявлено в интерфейсе, но вместо него есть группа методов для каждого типа содержимого ScLink с похожими названиями. Методы служат для изменения значения уже существующих ScLink. Для работы необходимо передать список ScLink, содержимое которых будет меняться, а также список содержимого. Содержимое каждого элемента списка ScLink будет заменено на соответствующий элемента списка содержимого. В результате метод вернёт ScLink с измененным содержимым. 

При работе с Ostis будет послан один запрос для каждого метода по отдельности. То есть, при вызове одного метода, будет послан один запрос. Но при вызове нескольких методов подряд, будет послано несколько запросов.

\subsubsection{getLinkContent}
Метод также заменён на группу методов со схожими названиями. Работают они аналогично методам setLinkContent. 

\subsubsection{findKeynodes}
Метод для поиска ключевых узлов по известному идентификатору. Если идентификатор существует, будет возвращён непустой Optional, в котором лежит узел. В противном случае, Optional будет пуст. 

\subsubsection{resolveKeynodes}
Метод для поиска и создания узлов по идентификатору. Если узла с переданным идентификатором не существует, будет создан новый узел с заданным типом, а иначе будет просто возвращён узел с указанным идеyтификатором (как в методе findKeynodes).

\subsection{Реализация запросов и ответов Ostis}

\subsubsection{Запрос}
Абстрактный запрос к sc-machine представлен интерфейсом \textbf{ScRequest}. Сервер sc-machine принимает следующие типы запросов: 
\begin{itemize}
\item create\_elements --- запрос на создание sc-элементов. В библиотеке ему соответствует интерфейс \textbf{CreateElementsRequest}. 
\item check\_elements --- запрос на проверку существования sc-элементов. В библиотеке он представлен интерфейсом \textbf{CheckScElTypeRequest}.
\item delete\_elements --- запрос на удаление sc-элементов. В библиотеке данный запрос описывает интерфейс \textbf{DeleteElementsRequest}.
\item search\_template --- запрос на поиск sc-конструкции по шаблону. Запросу соответствует интерфейс \textbf{FindByPatternRequest}.
% \item generate\_template --- запрос на создание sc-конструкций по шаблону. В коде представлен интерфейсом \textbf{GenerateByTemplateRequest}.
% \item events --- запрос на подпись на события. Ему соответствует интерфейс \textbf{EventSubscriptionRequest}.
\item keynodes --- запрос на получение и редактирование ключевых узлов (keynodes). В библиотеке представлен интерфейсом \textbf{KeynodeRequest}.
\item content --- запрос на получение и редактирование содержимого sc-links. Представлен интерфейсами \textbf{SetLinkContentRequest} и \textbf{GetLinkContentRequest} .
\end{itemize}

\subsection{Создание поисковых шаблонов}

Для поиска по шаблону в интерфейсе ScMachine описаны 3 метода: findByPattern3, findByPattern5, find.
Функционально методы аналогичны, различие заключается лишь в наличии проверки java-типов на этапе компиляции, а также удобства создания шаблонов. 
\begin{itemize}
\item findByPattern3. Для использования данного метода необходимо передать объект типа ScPattern3. Получить такой объект можно двумя способами. Первый способ наиболее предпочтительный и удобный -- использование одной из фабрик (DefaultScPattern3Factory, ScPattern3FactoryWithNames). В этом случае фабрике необходимо только передать искомые типы, а вся работа с generic-ами происходит внутри. Второй способ создания заключается в создании непосредственно объекта класса ScPattern3Impl, но это несколько сложнее, так как необходимо изучить семантику generic-параметров класса. 
\item findByPattern5. Для использования данного метода необходимо передать объект типа ScPattern5. Получить такой объект можно двумя способами. Первый способ наиболее предпочтительный и удобный -- использование одной из фабрик (DefaultScPattern5Factory, ScPattern5FactoryWithNames). В этом случае фабрике необходимо только передать искомые типы, а вся работа с generic-ами происходит внутри. Второй способ создания заключается в создании непосредственно объекта класса ScPattern5Impl, но это несколько сложнее, так как необходимо изучить семантику generic-параметров класса. 
\item find. Данный метод является обобщением поисковых шаблонов и может искать любые допустимые конструкции (включая конструкции на 3 и на 5 элементов). Для поиска необходимо передать объект типа ScPattern, который, в отличие от ScPattern3 и ScPattern5 не имеет такой строгой типобезопасности. Создать такой шаблон можно только одним способом -- созданием одной из реализаций интерфейса ScPattern (на данный момент доступен класс DefaultWebsocketScPattern). Однако, после создания необходимо наполнить объект шаблона правилами поиска. Каждое правило поиска представляет из себя тройку поисковых элементов. Поисковый элемент не является sc-элементом, но служит для описания sc-элементов, которые необходимо найти. На данный момент доступно 3 поисковых элемента:
\begin{enumerate}
\item ScFixedElement. Служит для указания в шаблоне конкретных (известных) sc-элементов. Может представлять любой элемент типа ScElement. При поиске указанные элементы являются "опорными" и не меняются (то есть, в каждой найденной конструкции будут присутствовать все фиксированные элементы).
\item ScTypedElement. Данный поисковый элемент описывает тип sc-элемента, который необходимо найти. Может принимать как значения типов узлов, дуг, линков, так и значение "неизвестного элемента", который в библиотеке представлен enum-ом UnknownScElement. Также поисковый элемент данного типа может иметь алиас. Алис, как понятно из названия, задаёт второе имя. Это может пригодиться в случае, если неизвестный элемент, который будет найден при поиске, участвует в другой конструкции. Как самый простой пример - поиск на 5 элементов, который можно составить из двух троек: \{фиксированный-узел, \textbf{дуга}, узел\}, \{фиксированный-узел-отношения, дуга-отношения, \textbf{дуга}\}. В примере мы не знаем адрес дуги, но при этом есть необходимость для второй тройки как-то эту дугу идентифицировать. 
\item ScAliasedElement. Данный поисковый элемент описывает алиас для ScTypedElement. Подробнее в предыдущем пункте. 
\end{enumerate}
\end{itemize}

